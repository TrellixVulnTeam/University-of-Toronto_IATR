#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>

int main(int argc, char **argv) {
    if (argc != 2) {
        printf("Usage:\n\tplay filename\n");
        return 0;
    }

    // to see man page for stat: man 2 stat


    /* 

      What's wrong with this approach?  (Compiler may give a warning.)
      We need to allocate space for the struct stat (not just for a pointer
      to struct stat).  Once we've allcated space (a buffer), we fill it up.
    */

    // struct stat *buf;
    // int ret = stat(argv[1], buf);
    // printf("stat returned %d\n", ret);


    /*/ Fix the type of buf as shown below.

    Now, let's examine the return type.  If ret == -1,
    an error occured.  If ret = 0, buf was populated with 
    information about the file at path argv[1]. 
    */

    struct stat stat_buf;
    int ret = stat(argv[1], &stat_buf);
    printf("stat returned %d\n", ret);

   

    /* But for a symbolic link stat returns info for the file being linked-to
       not the link file itself.
   
    Use lstat to populate struc with info about symbolic link named argv[1].
    */      

    ret = lstat(argv[1], &stat_buf);
    printf("lstat returned %d\n", ret);
    
    /* 
    Use the macros to file out about file attributes.
    */
    if (stat_buf.st_mode & S_IFREG) {
      printf("Regular file\n");
    } else if (stat_buf.st_mode & S_IFDIR) {
      printf("Directory\n");
    }

    if((stat_buf.st_mode & S_IRUSR) && (stat_buf.st_mode & S_IWUSR) && (stat_buf.st_mode & S_IXUSR)) {
      printf("Owner has rwx permissions\n");
    }

   return 0;
}
