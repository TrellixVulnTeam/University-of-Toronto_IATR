==============================================================================
CSC 373                  Lecture Summary for Week  5                 Fall 2014
==============================================================================

READINGS: Sections 26.1, 26.2, 26.3.
SELF-TEST: Exercises 26.1-1, 26.2-2.

------------
Network Flow
------------

Definition: "network" = directed graph N = (V,E) with
  - a single "source" s (- V with no incoming edge,
  - a single "sink" t (- V with no outgoing edge,
  - nonnegative integer "capacity" c(e) for each edge e (- E.
  - Networks can be used to model, e.g., computer networks (capacity =
    bandwidth), electrical networks, etc.
  - (Example: Figure 26.1 in textbook.)

Network flow problem: Assign flow f(e) (- R to each edge e such that we have
maximum flow "in the network" (to be defined), subject to:
  - capacity constraint: for each edge e, 0 <= f(e) <= c(e)
    (flow does not exceed capacity);
  - conservation constraint: for each vertex v != s,t, f^in(v) = f^out(v),
    where f^in(v) = total flow into v = sum_{(u,v) (- E} f(u,v) and
    f^out(v) = total flow out of v = sum_{(v,u) (- E} f(v,u);
  - total flow in network is denoted |f| and defined as |f| = f^out(s)
    (by conservation, |f| = f^in(t); this will be proved later).

Brute force? \Omega(\prod_{e (- E} c(e)) for integer flows -- each edge e can
    get a flow of 0,1,2,...,c(e), and we consider all possibilities
    independently of other edges -- much worse than simple exponential!

Greedy? No way to select any part of flow greedily.

Dynamic programming? No way to break down problem into independent recursive
    sub-problems.

Idea: Local search strategy: start with initial assignment of flow guaranteed
    to be correct but not necessarily maximum, then try to make incremental
    improvements -- stop when no improvement possible.

  - Ford-Fulkerson algorithm:
        start with any valid flow f (e.g., f(e) = 0 for all e (- E)
        while there is an "augmenting path" P
            "augment" f using P
        output f

Augmenting paths? Augment a flow?

  - Intuition: Since all flow must "start" at s and "end" at t, find s-t paths
    along which flow can be increased. Instead of adding flow to edges in
    haphazard manner, this preserves conservation.

  - First idea: path P = s -> ... -> t where f(e) < c(e) for each e.
    Define "residual capacity" for edges: \Delta_f(e) = c(e) - f(e), and
    residual capacity for paths: \Delta_f(P) = MIN_{e (- P} \Delta_f(e).
    Augment path by adding \Delta_f(P) to all edge flows.

  - Problem: notion too narrow, can get stuck with sub-optimal solution.
    (Example: f(s,a) = 8, f(s,b) = 13, f(a,c) = 12, f(b,a) = 4, f(b,d) = 9,
    f(d,c) = 5, f(d,t) = 4, f(c,t) = 17 on earlier network.)

  - Second idea: allow "backward" edges on path and re-define residual
    capacity of e:
        \Delta_f(e) = c(e) - f(e) if e is a forward edge on the path;
        \Delta_f(e) = f(e) if e is a backward edge on the path.
    Intuition: forward edge has "unused capacity" that can be used to push
    more flow from s to t; backward edge has "surplus flow" that can be
    redirected to push more flow from s to t.
    Note: this is a form of backtracking -- changing our mind about previously
    assigned flow.
    (Example: s -8/16-> a <-4/4- b -9/14-> d -5/7-> c -17/20-> t in earlier
    network -- edge (b,a) traversed in backward direction with residual
    capacity = f(b,a) = 4.)

  - Augmenting path = s-t path where each edge has positive residual capacity
    (i.e., c(e)-f(e) > 0 for forward edges e, f(e) > 0 for backward edges e).

  - Augmentation: add \Delta_f(P) (defined as before) to forward edges,
    subtract it from backward edges.

Correctness of Ford-Fulkerson Algorithm:

  - A "cut" is a partition of V into V_s, V_t (i.e., V = V_s u V_t and
    V_s n V_t = {}) such that s (- V_s, t (- V_t;
      . an edge (u,v) with u (- V_s, v (- V_t is a "forward" edge;
      . an edge (u,v) with u (- V_t, v (- V_s is a "backward" edge.
    Careful! Two different notions of "forward/backward": with respect to
    paths and with respect to cuts.

  - For any cut X=(V_s,V_t),
      . The "capacity" of cut X is the sum of the capacities of the forward
        edges: c(X) = sum_{e forward} c(e).
      . The "flow across X" is the total flow forward minus the total flow
        backward across the cut:
            f(X) = sum_{e forward} f(e) - sum_{e backward} f(e).

  - Example: X_0 = (V_x = {s,a}; V_t = {b,c,d,t}) on ongoing example network.
    c(X_0) = c(a,c) + c(s,b) = 12 + 13 = 25 -- don't count backward edge (b,a).

  - Lemma: For any cut X and any flow f, f(X) <= c(X).
    Proof:
        f(X) = sum_{e forward} f(e) - sum_{e backward} f(e)
            <= sum_{e forward} f(e)
            <= sum_{e forward} c(e) = c(X).

  - Lemma: For any cut X and any flow f, f(X) = |f|.
    Proof: See Lemma 26.5 in textbook.

  - Corollary: For any cut X and any flow f, |f| <= c(X). (From two facts
    above). In particular, max flow in network <= min capacity of any cut.

  - Theorem (Ford-Fulkerson): For any network N and flow f, |f| is maximum
    (and equal to c(X) for some cut X) iff there is no augmenting path.

    Proof: (=>) augment
    (<=) Construct cut X as follows:
      . start with V_s = {s}, V_t = V - {s};
      . if (u,v) (- E with u (- V_s, v (- V_t, f(u,v) < c(u,v), then move v
        from V_t to V_s;
      . if (u,v) (- E with v (- V_s, u (- V_t, f(u,v) > 0, then move u from
        V_t to V_s;
      . repeat until no further change possible.
    Since there is no augmenting path, this must stop with t (- V_t
    (otherwise, there is some augmenting path). By definition of X, every edge
    crossing X has property that f(e) = c(e) for forward edges and f(e) = 0
    for backward edges. Hence, |f| = f(X) = c(X).

    Corollary (max-flow/min-cut theorem): For any network, the maximum flow
    value equals the minimum cut capacity.

  - Additional property: because of nature of augmentation, can prove by
    induction that max flow can always be achieved with integer flow values
    (as long as all capacities are integer).

Choosing augmenting paths efficiently:

  - Example where it could take 2 * 10^100 augmentations to find max flow of
    2 * 10^100. In worst-case, Ford-Fulkerson takes time Theta(m f*), where f*
    is the value of a max flow -- this is not polytime.

  - Edmonds-Karp algorithm: use BFS (modified to consider only augmenting
    edges) to find augmenting paths; guaranteed to find an augmenting path
    with smallest # of edges in time O(m). Possible to prove that no more than
    O(mn) augmentations are required to find max. flow. Total time: O(nm^2) =
    O(n^5).

  - Dinic algorithm: perform complete BFS, use all augmenting paths w.r.t. BFS
    tree, then repeat. Worst-case time down to O(n^2m) = O(n^4).

  - "Preflow" algorithms: don't use augmenting paths; instead, push as much as
    possible along individual edges then go back to fix conservation. More
    complicated to explain and write down correctly, but cuts down time to
    O(n^3).

  - Why are we not concerned about details? Applications of network flow do
    not involve writing new algorithms: you always solve the same problem, so
    you can use an existing implementation that's already been debugged and
    optimized. Applications involve taking a problem, casting it in the guise
    of a network flow, solving the network flow problem, then casting the
    answer back to your problem.

Difference between Network Flow and other techniques:

  - When solving a problem by "using network flows", what we are doing is
    actually a *reduction* or *transformation*: we take the input to our
    problem and create a network from it, then use standard algorithms to
    solve the maximum flow problem on that network (it's always the same
    problem and always the same algorithm, only the input differs). Then, we
    use the solution to the network flow problem to reconstruct a solution to
    our problem.

    There are two ways that this could go wrong:
      . The network we construct could fail to represent certain solutions to
        our original problem. We show this is *not* the case by arguing that
        every solution to the original problem yields a valid flow (or cut) in
        the network.
      . The network we construct could have solutions that don't correspond to
        anything in our original problem. We show this is *not* the case by
        arguing that every flow (or, depending on the problem, every *integer*
        flow or every cut) in the network corresponds to a solution to the
        original problem.
    Sometimes those arguments can be very short, because the correspondence is
    obvious between both problems. But both arguments are important and must
    always be included.

------------------------------------------------------------------------------
[The next example was NOT done during Francois's lecture due to lack of time.
Please read it, and it will be covered very briefly next week.]

Applications of network flows:

  - Maximum bipartite matching:
    Input: An undirected bipartite graph G=(V_1,V_2,E) -- one where every edge
        is between V_1 and V_2 (i.e., no edge has both endpoints in the same
        "side").
    Output: A disjoint subset of edges of maximum size (i.e., no edge in a
        matching shares an endpoint with any other edge in the matching).

    Given input graph, create network by turning every original edge into a
    directed edge (from V_1 to V_2) with capacity 1; add source with edges of
    capacity 1 to each vertex in V_1, sink with edges of capacity 1 from each
    vertex in V_2.
      . Any matching in graph yields flow in network: set flow = 1 for graph
        edges in matching, 0 for graph edges not in matching; set flow = 1 for
        new edges to/from matched vertices, 0 for new edges to/from unmatched
        vertices.
      . Any integer flow in network yields matching in graph: pick edges with
        flow = 1 (leave out edges with flow = 0). No edge can have flow larger
        than 1 because of capacities.
    For this correspondence, size of matching = value of flow. Hence, any max
    flow in network yields a maximum matching in graph (because a larger
    matching would give a larger flow).

