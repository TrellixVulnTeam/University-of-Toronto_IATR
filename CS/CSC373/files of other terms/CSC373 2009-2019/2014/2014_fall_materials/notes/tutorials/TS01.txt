==============================================================================
CSC 373                 Tutorial Solutions for Week  1               Fall 2014
==============================================================================


 1. Algorithm:
        d = [1, 5, 10, 25]  # coin values (aka "denominations")
        k = 3  # start with largest denomination
        C = []  # list of coins used to make change
        while A > 0:
            if A < d[k]:
                # Try the next smaller denomination.
                # Because d[0] = 1, k cannot drop below 0.
                k = k - 1
            else:
                # Use one more coin of denomination d[k].
                C = C + [d[k]]
                A = A - d[k]

    Proof of correctness:
    Let C_0, C_1, ... be partial solutions generated by the algorithm.
    Say C_i is promising iff it can be extended into an optimal solution using
    only denominations no larger than the smallest coin in C_i.
    Proof that C_i is promising for all i.
    Base Case:
        C_0 = [] is extended by every optimal solution.
    Ind. Hyp.:
        Suppose C_i is promising, with optimal solution OPT_i.
    Ind. Step:
        Consider C_{i+1} = C_i + d[k_i].
        We want to show that OPT_i - C_i must already contain one coin with
        value d[k_i], so that OPT_i already extends C_{i+1} -- in other words,
        there is a unique optimal solution.
        For a contradiction, suppose this is not the case.
        Consider cases for d[k_i]:
          - d[k_i] = 25
            Since C_{i+1} = C_i + d[k_i], the amount remaining must exceed 25
            (A_i >= 25). If OPT_i - C_i does not contain any coin with value
            25, then it must make up A_i using only coins with values 1, 5 and
            10. But any combination of these coins that adds up to more than
            25 can be replaced by a combination that contains 25 and uses
            fewer coins. (*)
          - d[k_i] = 10
            Similar reasoning shows any combination of 1c and 5c coins that
            adds up to 10c or more must contain some sub-collection that adds
            to exactly 10c, which could be replaced by a single coin to get a
            solution better than OPT_i.
          - d[k_i] = 5
            As above.
          - d[k_i] = 1
            It is impossible to make up amounts of 1c or more *without* using
            any coin!
        In every case, we get a contradiction. Hence, OPT_i already extends
        C_{i+1}.
    When the algorithm stops, the final value of C is promising (by the proof
    above). But at the same time, C contains coins that add up to exactly A.
    In other words, C is optimal.

    (*) Relies on the following fact: every optimal solution contains
          - at most two 10c, one 5c, and four 1c pieces,
          - not two 10c and one 5c pieces together.
        This can be proved with a simple case-by-case analysis.


 2. Consider the case d = [1, 10, 25] and A = 30.
    Then the greedy algorithm generates the solution [25, 1, 1, 1, 1, 1].
    But [10, 10, 10] is another solution that uses fewer coins.


*3. [No sample solution for "starred" problems!
    Post on Piazza for discussion, if you're interested.]

