==============================================================================
CSC 373                 Tutorial Solutions for Week  8               Fall 2014
==============================================================================


 1. The following algorithm decides TRIANGLE.

        On input G:
            For each triplet of vertices (u,v,w) in G:
                Return True if G contains each edge (u,v), (v,w), (w,u).
            Return False if no triplet checked out.

    By definition of TRIANGLE, the algorithm will return True iff G contains a
    triangle.
    Let n = |V| (number of vertices) and m = |E| (number of edges) in G. There
    are (n choose 3) = \Theta(n^3) many triplets of vertices in G, and it is
    possible to enumerate them one by one in time O(n^3). For each triplet,
    it takes time O(m) to verify the presence of the three edges (depending on
    how G is encoded, this could be reduced). So the algorithm runs in time
    O(m n^3).


 2. Verifier for CLIQUE:

        On input <G,k,c>, where c is a subset of vertices:
            Return True if c contains k vertices and G contains edges
            between all pairs of vertices in c; return False otherwise.

    Verifier runs in polytime (where n = |V|, m = |E|): checking all pairs of
    vertices in c takes time O(k^2 m) (O(k^2) pairs in c, time O(m) for each
    one).
    If <G,k> (- CLIQUE, then verifier returns True when c = a k-clique of G;
    if verifier returns True for some c, then <G,k> (- CLIQUE (c is a
    k-clique).

    CLIQUE (- P? Unknown (checking all possible subsets not polytime because k
    not fixed, part of input).

 -  Contrast CLIQUE with TRIANGLE: TRIANGLE (- NP (on input <G,c>, check c
    encodes a triangle in G), but TRIANGLE (- P as well.

    What's the difference? Same algorithm to decide CLIQUE takes time
    O(n^{k+1}), except that k is part of the input (instead of being fixed) so
    this could be as bad as, e.g., O(n^{n/2}) -- not polytime.


 3. (a) UNARY-PRIMES (- P. Algorithm:

            On input 1^n:
                For k = 2,3,...,n-1:
                    If k divides n, return False
                Return True if no value of k worked.

        The algorithm returns True iff k is prime, by definition. The division
        can be carried out by repeated subtraction, which takes time O(n^2)
        for each value of k, so the entire algorithm runs in time O(n^3).

        NOTE:  This works because n is the *size* of the input at the same
        time as the *value* of the input: for any other base, this would not
        work because the value n would be represented using m = log n many
        digits so the size would be proportional to m = log n and the running
        time would become exponential (as a function of m).

    (b) SUBSET-SUM (- NP. Verifier:

            On input <S,t,c>, where c is a subset of S:
                Return True if \sum_{y (- c} y = t; return False otherwise.

        Clearly runs in polytime (addition of numbers is polytime), and if
        <S,t> (- SUBSET-SUM, then there is some value of c such that verifier
        returns True (c = subset whose sum equals t); if verifier returns True
        for some c, then <S,t> (- SUBSET-SUM (c is subset with sum t).

    (c) NON-ZERO (- coNP. Verifier:

            On input <S,c>, where c is a subset of S:
                Return False if \sum_{y (- c} y = 0; return True otherwise.

        Runs in polytime (addition of numbers is polytime) and returns False
        for some c (c = subset with zero sum) if <S> !(- NON-ZERO; returns
        True for all c if <S> (- NON-ZERO.

