==============================================================================
CSC 373                 Tutorial Solutions for Week  4               Fall 2014
==============================================================================

[Section 25.1 in the textbook has an alternative presentation.]

 0. Recursive structure:

    Consider shortest u-v path P. Either P = (u,v) or P = shortest u-t path +
    (t,v) for some vertex t -- if u-t part of P not shortest, hypothetical
    shorter u-t path + (t,v) would yield shorter u-v path.

 1. Array definition:

    For all u,v in V, k in {1,...,m = |E|}, A[m,u,v] = weight of shortest u-v
    path with at most m edges. (Possible to start with k = 0 instead.)

 2. Recurrence:

      * A[1,u,u] = 0, for all u in V
        (degenerate "path" with no edge from u to u)
      * A[1,u,v] = w(u,v), for all (u,v) in E
        (every edge is a path with one edge)
      * A[1,u,v] = oo, for all (u,v) not in E
        (no edge (u,v) means no path with just one edge from u to v)

      * A[k,u,v] = min( A[k-1,u,v], A[k-1,u,t] + w(t,v) : (t,v) in E ),
        for all k in {2,...,m}, u,v in V
        (shortest path with at most k edges either uses at most k-1 edges or
        uses at most k-1 edges followed by one last edge to v)

 3. Iterative algorithm:

        for u in V:
            for v in V:
                if u = v:
                    A[1,u,v] = 0
                elif (u,v) in E:
                    A[1,u,v] = w(u,v)
                else:
                    A[1,u,v] = oo
        for k = 2,3,...,m:
            for u in V:
                for v in V:
                    A[k,u,v] = A[k-1,u,v]
                    for all edges (t,v) in E:
                        if A[k-1,u,t] + w(t,v) < A[k,u,v]:
                            A[k,u,v] = A[k-1,u,t] + w(t,v)

 4. Optimum solution:

    At the end, A[m,u,v] = length of shortest u-v path. But finding path
    requires knowing last vertex before v on this path. Use second array:

        for u in V:
            for v in V:
                if u = v:
                    A[1,u,v] = 0
                    B[1,u,v] = 0
                elif (u,v) in E:
                    A[1,u,v] = w(u,v)
                    B[1,u,v] = u
                else:
                    A[1,u,v] = oo
                    B[1,u,v] = 0
        for k = 2,3,...,m:
            for u in V:
                for v in V:
                    A[k,u,v] = A[k-1,u,v]
                    for all edges (t,v) in E:
                        if A[k-1,u,t] + w(t,v) < A[k,u,v]:
                            A[k,u,v] = A[k-1,u,t] + w(t,v)
                            B[k,u,v] = t

    Now use computed values to reconstruct path:

        Path(u,v):
            if B[m,u,v] = 0:
                return []
            else:
                return Path(u,B[m,u,v]) + [(B[m,u,v],v)]

Runtime? Theta(m n^2 m) for loop that computes A and B; Theta(n) for final
path reconstruction. In the worst case, could be as high as Theta(n^6), if m
in Omega(n^2) -- worse than algorithm from lecture.


Addendum
--------

But wait! Does k really need to loop all the way up to m? Since shortest paths
must be simple, every path we are interested in contains at most n-1 edges.
This means we can shorten the loop over k to make it go up to n only. The
running time then becomes Theta(n^3 m) = O(n^5).

But wait again! Counting runtime of m for the loop over edges (t,v) is wrong:
we need to look at most at every other vertex t once. So each one of the loops
really makes O(n) iterations -- the total runtime is Theta(n^4) in the
worst-case.

