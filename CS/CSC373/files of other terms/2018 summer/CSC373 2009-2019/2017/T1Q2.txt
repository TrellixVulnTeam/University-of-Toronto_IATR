Question 2

(a)

Take three smallest frequencies and make them leaves of a new node. Merge these frequencies into a new character whose frequency is the combined frequency of the three. Recurse.

(b)
TernaryHuffman(f,n)
  Q = PriorityQueue(f)
  while Q.size() > 1
    let z be a new node
    z.left = Q.ExtractMin()
    z.middle = Q.ExtractMin()
    z.right = Q.ExtractMin()
    z.freq = z.left.freq+z.middle.freq+z.right.freq
    Q.insert(z)
  return Q.ExtractMin()

(c)

Three lowest frequencies have to appear at max depth, for otherwise we could exchange a higher frequency at max depth with a lower frequency at a lower depth and this would increase the overall compression.

Given an optimal solution to the original problem, it has to contain an optimal solution to the reduced subproblem resulting from merging the three lowest frequencies. Otherwise we could take a better solution for the subproblem and expand the leaf corresponding to the three merged frequencies obtaining a better solution for the original problem.

(d)

Assuming priority queue is implemented using binary heap, we have O(log n) per ExtractMin/insert ops & we perform const number of those per iteration and number of iterations is O(n). Thus, overall runtime is O(n log n).