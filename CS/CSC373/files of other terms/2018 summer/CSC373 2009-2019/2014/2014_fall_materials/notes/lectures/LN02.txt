==============================================================================
CSC 373                  Lecture Summary for Week  2                 Fall 2014
==============================================================================

READINGS: Sections 23, 24 (overview), 24.3.
SELF-TEST: Exercises 23.1-1 23.1-5, 24.3-1.

Minimum Spanning Tree -- Continued

  - Correctness of Kruskal's algorithm.

    First, spell out algorithm in pseudo-code:
        Sort edges s.t. c(e_1) <= c(e_2) <= ... <= c(e_m).
        T = {}
        for j = 1,2,...,m:
            let (u,v) = e_j
            if T does _not_ contain a path between u and v:
                T := T u {e_j}

    Algorithm generates subsets of edges T_0, T_1, ..., T_m.
    Say T_i is "promising" if it can be "extended" to some MST T*_i using only
    edges {e_{i+1},...,e_m}, i.e., T_i (_ T*_i (_ T_i u {e_{i+1},...,e_m}.

    Loop invariant: T_i is promising.

    Base:  T_0 = {} is promising: every MST T* is a subset of {e_1,...,e_m}.

    I.H.:  Suppose i >= 1 and T_i can be extended to T*_i.

    Step:  Either T_{i+1} = T_i or T_{i+1} = T_i u {e_{i+1}}.

        Case 1:  If T_{i+1} = T_i, then T_i u {e_{i+1}} contains a cycle.
            Since T_i (_ T*_i and T*_i is a MST, e_{i+1} !(- T*_i, so
            T_{i+1} (_ T*_i (_ T_{i+1} u {e_{i+2},...,e_m}, i.e., T*_i extends
            T_{i+1} so we can set T*_{i+1} = T*_i.

        Case 2:  If T_{i+1} = T_i u {e_{i+1}}, then consider whether or not
            e_{i+1} (- T*_i.

            Subcase A:  If e_{i+1} (- T*_i, then
                T_{i+1} (_ T*_i (_ T_{i+1} u {e_{i+2},...,e_m}, i.e., T*_i
                extends T_{i+1} so we can set T*_{i+1} = T*_i.

            Subcase B:  If e_{i+1} !(- T*_i, then T*_i does not extend
                T_{i+1}. Must construct some T*_{i+1} that does.
                Consider endpoints of e_{i+1} in T*_i: they are connected by a
                path. Fact: not all edges on this path belong to T_i -- else
                algorithm would not generate T_{i+1} = T_i u {e_{i+1}}.
                So T*_i contains some edge e_j on this path with j >= i
                (because T*_i agrees with T_i on all edges e_1,...,e_i). Then
                c(e_j) >= c(e_{i+1}) and we can set
                    T*_{i+1} = T*_i u {e_{i+1}} - {e_j}.
                T*_{i+1} is a MST: it is connected, acyclic, and with total
                cost <= total cost of T*_i -- in fact, it must be that c(e_j)
                = c(e_{i+1}) since T*_i is also optimal.

        In every case, T_{i+1} is promising.

    Since every T_i is promising, T_m is promising. But this means T*_m = T_m
    since there are no edges left to consider. So T_m is optimal.

  - Correctness of other algorithms proved similarly.

Shortest Paths
    Input: connected graph G = (V,E) with edge costs c(e) for all e (- E;
        vertices s,t (- V. IMPORTANT: costs are POSITIVE integers.
    Output: a path from s to t with minimum total cost ("shortest" path).

  - Brute-force: in general, exponentially many paths possible.

  - Special case: if c(e) = 1 for all e: BFS!

  - In general: "adjusted" BFS: use a _priority queue_ instead of a queue to
    collect unvisited vertices; set priority = shortest distance so far

  - Algorithm:

        # Initialization.
        S = {}
        initialize empty priority queue
        for all v in V:
            p[v] = NIL  # predecessor of v on shortest s-v path so far
            d[v] = oo   # priority of v = minimum distance s-v so far
            enqueue v   # with priority d[v] = oo
        d[s] = 0
        update queue order of s
        
        # Main loop.
        while queue is not empty:
            v = dequeue element with minimum priority d[]
            if p[v] != NIL:  S = S u {(p[v],v)}
            for all edges (v,u):
                if u is in the queue and d[v] + c(v,u) < d[u]:
                    p[u] = v
                    d[u] = d[v] + c(v,u)
                    update queue order of u
        
        return S

  - Runtime:
      - O(n) for initialization.
      - O(m) for loop over edges containing s.
      - Main loop iterates at most n times (each iteration removes one vertex
        from the queue).
      - Each iteration examines a subset of edges and updates priorities. Over
        all iterations, each edge generates at most one queue update. And each
        priority update takes time O(log n) using a heap.
      - Total: O(m log n).

  - Correctness:

    Algorithm generates subsets of edges S_0, S_1, ..., S_{n-1}.
    Say S_i is "promising" if it can be "extended" to some collection of
    shortest paths S*_i (really, a shortest paths tree) using only edges that
    do not have *both* endpoints "in" S_i, i.e., edge with at least one
    endpoint still in the queue. (Technically, S_i contains edges, not
    vertices: when we speak of a vertex being "in" S_i, we mean that it is the
    endpoint of some edge in S_i.)

    Loop invariant:
      - S_i is promising, and
      - for all u in S_i, all v outside S_i,
        d[u] = dist(s,u) <= dist(s,v) <= d[v]
    where dist(s,v) is the minimum cost of all paths from s to v.
    (Extra clause is required for the proof to go through.)

    Proven by induction on i.

    Base Case:
        S_0 = {} is promising, trivially.

    Ind. Hyp.:
        For some arbitrary i, suppose S_i can be extended to some shortest
        paths tree S*_i, using only edges without both endpoints in S_i, and
        that d[u] = dist(s,u) <= dist(s,v) <= d[v] for all u in S_i and v
        outside S_i.

    Ind. Step:
        Consider S_{i+1} = S_i u {(u,v)}, with u in S_i and v outside S_i.
        Either (u,v) (- S*_i or it does not.

        If (u,v) (- S*_i, then S*_i extends S_{i+1}.
        Also, dist(s,v) = dist(s,u) + c(u,v) (because (u,v) in S*_i) so
        d[v] = d[u] + c(u,v) = dist(s,u) + c(u,v) = dist(s,v).
        Moreover, because d[v] was the smallest of the d[] values for vertices
        outside S_i, d[x] = dist(s,x) <= dist(s,w) <= d[w] for all
        x in S_{i+1} and all w outside S_{i+1}.

        If (u,v) !(- S*_i, then:
          - consider the path P in S*_i from s to v, and let (w,v) be the
            last edge edge on this path
          - if w were outside S_i, then let (x,y) be the first edge on P with
            x in S_i, y outside S_i
              . d[y] <= d[x] + c(x,y) (because d[y] is the smallest value of
                             d[t] + c(t,y) for all edges (t,y) with t in S_i))
                      = dist(s,x) + c(x,y)
                     <  dist(s,x) + c(x,y) + dist(y,v)
                           (since all edge costs are positive)
                      = dist(s,v)
                     <= d[v]
              . but this contradicts the fact that d[v] is the smallest
                value of d[t] for all vertices t outside S_i
            so w in S_i
          - so dist(s,v) = dist(s,w) + c(w,v) = d[w] + c(w,v)
          - since d[v] is the minimum of d[x] + c(x,v) over vertices x, this
            means d[v] <= d[w] + c(w,v) = dist(s,v)
          - so d[v] = dist(s,v) (it cannot be smaller)
          - so we can let S*_{i+1} = S^i - {(w,v)} u {(u,v)}, and after the
            update to d[w] for all edges (v,w) with w outside S_i, we still
            have that d[x] = dist(s,x) <= dist(s,y) <= d[y] for all x in S_i,
            y outside S_i

    Hence, the loop invariant holds. When the algorithm terminates, this means
    d[u] = dist(s,u) for all vertices u: we have found shortest paths to every
    vertex.

