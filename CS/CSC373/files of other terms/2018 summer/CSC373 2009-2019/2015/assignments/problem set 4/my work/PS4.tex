\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{clrscode3e}

\setlength{\parskip}{2ex}
\newcommand{\qedsymb}{\hfill{\rule{2mm}{2mm}}}
\newenvironment{proof}{\vspace{-1mm}\begin{trivlist}
}{\qedsymb\end{trivlist}\vspace{-1mm}}

\begin{document}
\begin{center}
{\bf \Large \bf CSC373 Winter 2015 Problem Set \# 4}\\
Name: Weidong An\\
Student Number: 1000385095\\
UTOR email: weidong.an@mail.utoronto.ca\\
\today\\
\end{center}

\begin{enumerate}[label=(\alph*)]

\item {\bf Recursive Structure}\\
The minimum total time required $\const{MinimumTime}(s_1...s_m)$ can be written as \\$\const{MinimumTime}(s_{1}...s_{p_c}) + \const{MinimumTime}(s_{p_c+1}...s_{m}) + |m|$ \\recursively for some $1 \leq c \leq k$ and $q_c$ is the first break point.

\item {\bf Array Definition}\\
For convenience, let $q_0 = 0$ and $q_{k+1} = m$.\\
Define array $T[i, j]$ with $0 \leq i < j \leq k +1$.\\
$T[i, j]$ = minimum time required to break the string $s_{p_i+1}...s_{p_j}$.

\item {\bf Recurrence Relation}\\
Base case: $T[i, i + 1] = 0$\\
General case($j - i > 1$): $T[i, j] = $ min$(T[i, b] + T[b, j]) + |p_j- p_i|$ for all $i + 1 \leq p \leq j-1$.
Explanation: For $T[i, j]$, if $j = i + 1$, then there is no breakpoint, so 0 is as desired. Otherwise $j - i > 1$, there must be a break point $p_b$ that is chosen first to minimize the total time. Then the time required is the sum of time of breaking $s_i...s_{p_b}$ and $s_{p_b+1}...s_j$ plus $|p_j - p_i|$.\\

\item {\bf Iterative Algorithm}\\
The following pseudocode is based on the recurrence relation defined above.
\begin{codebox}
\li \For $t \gets 1, ..., k+1$
\li     \Then \For $i \gets 0, ..., k-t+1$ $\#$ $i$ denotes the row, $i + t$ denotes the column
\li               \Then \If $t \isequal 1$
\li                        \Then $T[i, i + t] \gets 0$
\li                     \Else
\li                          $T[i, i + t] \gets \infty$
\li                          \For $p \gets i + 1, ..., i+t-1$ $\#$This loop is to find the minimum
\li                               \Then \If $T[i, p] + T[p, i +t] + |p_{i + t}- p_i| < T[i, i + t]$
\li                                         \Then $T[i, i + t] \gets T[i, p] + T[p, i +t] + |p_{i + t}- p_i|$

\end{codebox}

\item {\bf Reconstruct Solution}\\
Define another array $B$ to store the result. $B[i, j] = b$ means the first break point in $s_{p_i+1}...s_{p_j}$ chosen is $p_b$. The following pseudocode is the same as above except line 9 and line 11.

\begin{codebox}
\li \For $t \gets 1, ..., k+1$
\li     \Then \For $i \gets 0, ..., k - t+ 1$
\li               \Then \If $t \isequal 1$
\li                        \Then $T[i, i + t] \gets 0$
\li                     \Else
\li                          $T[i, i + t] \gets \infty$                         
\li                          \For $b \gets i + 1, ..., i+t-1$ 
\li                               \Then \If $T[i, b] + T[b, i +t] + |p_{i + t}- p_i| < T[i, i + t]$
\li                                         \Then    $intermed \gets b$
\li                                                  $T[i, i + t] \gets T[i, b] + T[b, i +t] + |p_{i + t}- p_i|$\End\End
\li                                      $B[i, i + t] \gets intermed$

\end{codebox}

To get the optimum permutation, first define the recursive function.

\begin{codebox}
\Procname{$\proc{Get-Optimal-Permutation}(B, i, j)$}
\li \If $j - i \isequal 1$
\li     \Then \Return $[]$
\li \Else
\li     \Return $[B[i, j]] + \proc{Get-Optimal-Permutation}(B, i, B[i, j]) + $\zi $\proc{Get-Optimal-Permutation}(B, B[i, j], j)$
\end{codebox}

Then implement the following:
\begin{codebox}
\li \Return $\proc{Get-Optimal-Permutation}(B, 0, k + 1)$
\end{codebox}
Because we have set $p_0 = 0$ and $p_{k+1} = m$, the result is in terms of $s_1...s_m.$



\end{enumerate}

\end{document}
