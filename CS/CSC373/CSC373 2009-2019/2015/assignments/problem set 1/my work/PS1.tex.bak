\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{clrscode3e}

\setlength{\parskip}{2ex}
\newcommand{\qedsymb}{\hfill{\rule{2mm}{2mm}}}
\newenvironment{proof}{\vspace{-1mm}\begin{trivlist}
}{\qedsymb\end{trivlist}\vspace{-1mm}}

\begin{document}
\begin{center}
{\bf \Large \bf CSC373 Winter 2015 Problem Set \# 1}\\
Name: Weidong An\\
Student Number: 1000385095\\
UTOR email: weidong.an@mail.utoronto.ca\\
\today\\
\end{center}

\begin{enumerate}[label=(\alph*)]
\item\label{algo}%
The pseudocode is as follows:
\begin{codebox}

\Procname{$\proc{Optimal-Permutation}()$}
\li $\pi \gets$ empty array
\li $T = \{1, ..., n\}$
\li \While $T \neq \emptyset$
\li     \Then $min = \infty$
\li     \For each $p \in T$    // This for-loop finds one of the minimum process in $T$
\li            \Then \If $t_p < min$
\li                  \Then $min \gets t_p$
\li                        $min$-$process \gets p$\End\End
\li      append $min$-$process$ to the end of $\pi$
\li      $T \gets T - \{min$-$process\}$\End
\li \Return $\pi$


%\Procname{$\proc{Optimal-Permutation}()$}
%\li $\pi \gets$ empty array
%\li sort $t_1, ..., t_n$ into nondecreasing order by processing times
%\li \For each $t_i \in \{t_1, ..., t_n\}$ taken in nondecreasing order by processing times
%\li       \Then append $i$ to the end of $\pi$\End
%\li \Return $\pi$

\end{codebox}


\item\label{partial}%
Define $\pi_i$ be the array $\pi$ after the $i^{th}$ iteration of the while-loop.\\
The example: $t_1, t_2, t_3, t_4=2, 5, 3, 2$\\
%Suppose the result in line 2 in the algorithm is $t_1, t_4, t_3, t_2$.\\
Then the "partial solutions" are:\\
$\pi_0 =$ empty array\\
$\pi_1 = [1]$\\
$\pi_2 = [1, 4]$\\
$\pi_3 = [1, 4, 3]$\\
$\pi_4 = [1, 4, 3, 2]$\\



\item\label{promising}%
Definition: Let $\pi_{OPT}$ be an optimal permutation of $1, ..., n$ that minimizes the average completion time $(C_1+...+C_n)/n$. We say $\pi_{OPT}$ extends $\pi_i$ if $\pi_i = \pi_{OPT}[1..i]$. $\pi_1$ is promising if there exists some optimal permutation $\pi_{OPT} $ of $1, ..., n$ that $\pi_{OPT}$ extends $\pi_i$.


\item\label{invariant}%
Loop invariant: $\pi_i$ is promising for all $i = 0, ..., n$.\\
The quantity to induction on: the number of iterations $i$ of the while-loop.

\item\label{cases}%
Only one case would be considered. The choice made by the greedy algorithm is the process with minimum processing times among the left processes.

\item\label{subcases}%
Notation: Let $min$-$process_{i}$ be the value of $min$-$process$ after the $i^{th}$ iteration of the while-loop. In the induction hypothesis, let $\pi_{OPT}$ be the optimal permutation for $i = k$. I.H: $\pi_{k}$ is promising.\\
Subcase 1: $min$-$process_{k + 1} = \pi_{OPT}[k + 1]$\\
Subcase 2:  $min$-$process_{k+ 1} \neq \pi_{OPT}[k+1]$

\item\label{conclusion}%
Suppose $\pi_i$ is promising for all $ i= 0, ..., n$ which means there exists some optimal permutation $\pi_{OPT}$ of $1, ..., n$ that $\pi_{OPT}$ extends $\pi_i$ for all $i = 0, ..., n$.\\
In particular, $\pi_n$ is promising. (i.e There is an optimal permutation $\pi_{OPT}$ that $\pi_n = \pi_{OPT}[1..n]=\pi_{OPT}$.) The loop terminates after $n$ iterations since the cardinality of $T$ decrements by 1 after each iteration. Hence, the result returned by the algorithm is $\pi_n = \pi_{OPT}$. This has proved that the algorithm from part (a) always produces an optimal solution.


\end{enumerate}

\end{document}
