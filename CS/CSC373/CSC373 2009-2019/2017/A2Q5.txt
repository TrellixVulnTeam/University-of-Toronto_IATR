Clarification: you may assume that the given maximum flow f is integral.

(a)
Construct a weighted graph G' = (V, E') with weights w : E' -> R, such that
  if (u,v) has residual capacity c_f(u,v) > 0 then (u,v) in E' and w(u,v) = 0
  if (u,v) has residual capacity c_f(u,v) == 0 and (u,v) in E then (u,v) in E' and w(u,v) = p(u,v)

Observe that G' has positive edge-weights. Run Dijkstra's algorithm from s on G'. Return the edges (u,v) on the shortest path computed by Dijkstra from s to v such that w(u,v) > 0.

(b)
ComputeEdgesToIncrease(G=(V,E),s,t,c,f,p)
  initialize graph G' on vertices V and weight function w
  for each edge (u,v) in E
    if c_f(u,v) > 0
      add (u,v) to E'
      w(u,v) = 0
    if c_f(v,u) > 0
      add (v,u) to E'
      w(v,u) = 0
    if c_f(u,v) == 0
      add(u,v) to E'
      w(u,v) = p(u,v)
  Run Dijkstra on G',w from vertex s
  Dijkstra computes arrays dist[] and prev[]
  
  Result = empty set
  end = t
  while end != s
    if w(prev[end],end) > 0
      Result.add((prev[end],end))
    end = prev[end]

  return Result

(c)
By Max-Flow Min-Cut theorem we can increase flow f by one unit if and only if there is an augmenting path in G_f (since flow and capacities are integral, the residual capacity of such a path would be at least 1). Since f is maximum there are no more augmenting paths. In particular, this happenned because certain edges that were present in G disappeared from G_f as they got saturated (their residual capacities became 0). We can reintroduce edge e by increasing its capacity by 1 and paying the price p(e). Thus, the original question of this problem can be rephrased as finding the cheapest augmenting path in the graph G' that has all edges of G_f with weight 0 (those are readily available to be used in augmenting path without any extra price) and the edges of G that got saturated by f with the weight given by p. This is precisely what the algorithm does. 

(d)
Constructing the graph G' and the weights w takes O(|V| + |E|) time assuming the input graph is given in the adjacency lists representation. Running Dijkstra on this graph and using the binary heap implementation of the priority queue results in the dominating part of the overall runtime O((|V|+|E|)log |V|). This is because, the last part -- reconstructing the solution -- takes O(|V|) time.