(a) 
For each vertex v in V we compute n[v] = number of distinct shortest paths from s to v. We start with n[s] = 1 and all other values 0. We fill in the array n[] in the BFS manner, in addition to the regular dist[] array - array of shortest unweighted distances from s to v. Suppose BFS processes edge {v,u} from v. If u was not discovered before (n[u] == 0) then u is discovered and n[u] = n[v]. If u was discovered before and dist[u] == dist[v]+1 then we update n[u] += n[v].

(b)
CountPaths(Adj, s, t)
  init arrays n[] and dist[] of size |V| each
  for v in V
    n[v] = 0
    dist[v] = infinity
  n[s] = 1
  dist[s] = 0
  Q = new queue({s})
  while Q is not empty
    v = Q.pop()
    for u in Adj[v]
      if n[u] == 0
        n[u] = n[v]
        dist[u] = dist[v]+1
        Q.push(u)
      else if dist[u] == dist[v]+1
        n[u] += n[v]
  return n[t]

(c)
We may assume that dist[] array is computed correctly by correctness of BFS.

We shall prove that n[v] is computed correctly by induction on dist[v].

Base case: dist[v] == 0. This means that v = s and there is a unique shortest path from s to s - namely, the empty path. Thus n[s] = 1.

Inductive step: n[v] is computed correctly for all v that are at distance k from s, i.e., for all v such that dist[v] = k. Moreover, n[v] is computed correctly by the time v is taken off the queue.

Let u be a vertex at distance k+1, i.e., dist[u] = k+1. Every shortest path from s to u has to go through some vertex at distance k that is a neighbor of u. Let v_1, ..., v_p be all such vertices through which shortest paths from s to u pass and dist[v_i] = k for all i. Then, the number of distinct shortest paths from s to u is equal to the number of distinct shortest paths from s to v_1 plus the number of distinct shortest paths from s to v_2, and so on all the way to v_p, i.e., n[u] should be equal to sum_{i=1}^p n[v_i]. By induction hypothesis, n[v_i] is computed correctly for all i. Moreover, all the v_i appear and are processed prior to u in the queue. Without loss of generality, assume that v_i's appear in the order v_1, ..., v_p in the queue. When v_1 is processed, n[u] == 0, so the "if" statment passes and n[u] is updated to n[v_1]. For each v_i with i >= 2 the "else if" statement passes, and n[u] is updated to include n[v_i]. Thus, by the time u is taken off the queue, it has the value n[u] = sum_{i=1}^p n[v_i].

Special case: dist[v] == infinity. This means that v is not reachable from s, thus n[v] is never updated, so n[v] == 0 at termination, which is the right value.

(d) The runtime is linear O(|V|+|E|). The runtime is dominated by the while loop, and we can count the number of queue operations as a proxy for the runtime. The number of pop() operations is bounded by the number of vertices (since the same vertex is never inserted in the queue more than once) and the number of push() operations is bounded by the number of edges. Since Q is a regular queue, each operation takes O(1) time. The other operations of addition, initialization, etc. are subsumed by the O(|V|+|E|) bound.